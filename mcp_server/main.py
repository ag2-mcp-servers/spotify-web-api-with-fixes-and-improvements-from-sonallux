# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T09:52:29+00:00



import argparse
import json
import os
from typing import *
from typing import Optional, Union

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import BaseSecurity, UnsuportedSecurityStub
from pydantic import confloat, conint

from models import (
    AlbumObject,
    AlbumsGetResponse,
    AlbumsGetResponse1,
    AlbumsIdGetResponse,
    AlbumsIdTracksGetResponse,
    ArtistObject,
    ArtistsGetResponse,
    ArtistsGetResponse1,
    ArtistsIdAlbumsGetResponse,
    ArtistsIdGetResponse,
    ArtistsIdRelatedArtistsGetResponse,
    ArtistsIdRelatedArtistsGetResponse1,
    ArtistsIdTopTracksGetResponse,
    ArtistsIdTopTracksGetResponse1,
    AudioAnalysisIdGetResponse,
    AudioAnalysisObject,
    AudiobookObject,
    AudiobooksGetResponse,
    AudiobooksGetResponse1,
    AudiobooksIdChaptersGetResponse,
    AudiobooksIdGetResponse,
    AudioFeaturesGetResponse,
    AudioFeaturesGetResponse1,
    AudioFeaturesIdGetResponse,
    AudioFeaturesObject,
    BrowseCategoriesCategoryIdGetResponse,
    BrowseCategoriesCategoryIdPlaylistsGetResponse,
    BrowseCategoriesGetResponse,
    BrowseCategoriesGetResponse1,
    BrowseFeaturedPlaylistsGetResponse,
    BrowseNewReleasesGetResponse,
    BrowseNewReleasesGetResponse1,
    CategoryObject,
    ChapterObject,
    ChaptersGetResponse,
    ChaptersGetResponse1,
    ChaptersIdGetResponse,
    CurrentlyPlayingContextObject,
    CurrentlyPlayingObject,
    CursorPagingPlayHistoryObject,
    DevicesObject,
    EpisodeObject,
    EpisodesGetResponse,
    EpisodesGetResponse1,
    EpisodesIdGetResponse,
    IncludeExternal,
    MarketsGetResponse,
    MarketsGetResponse1,
    MeAlbumsContainsGetResponse,
    MeAlbumsContainsGetResponse1,
    MeAlbumsDeleteRequest,
    MeAlbumsDeleteResponse,
    MeAlbumsGetResponse,
    MeAlbumsPutRequest,
    MeAlbumsPutResponse,
    MeAudiobooksContainsGetResponse,
    MeAudiobooksContainsGetResponse1,
    MeAudiobooksDeleteResponse,
    MeAudiobooksGetResponse,
    MeAudiobooksPutResponse,
    MeEpisodesContainsGetResponse,
    MeEpisodesContainsGetResponse1,
    MeEpisodesDeleteRequest,
    MeEpisodesDeleteResponse,
    MeEpisodesGetResponse,
    MeEpisodesPutRequest,
    MeEpisodesPutResponse,
    MeFollowingContainsGetResponse,
    MeFollowingContainsGetResponse1,
    MeFollowingDeleteRequest,
    MeFollowingDeleteResponse,
    MeFollowingGetResponse,
    MeFollowingGetResponse1,
    MeFollowingPutRequest,
    MeFollowingPutResponse,
    MeGetResponse,
    MePlayerCurrentlyPlayingGetResponse,
    MePlayerDevicesGetResponse,
    MePlayerGetResponse,
    MePlayerNextPostResponse,
    MePlayerPausePutResponse,
    MePlayerPlayPutRequest,
    MePlayerPlayPutResponse,
    MePlayerPreviousPostResponse,
    MePlayerPutRequest,
    MePlayerPutResponse,
    MePlayerQueueGetResponse,
    MePlayerQueuePostResponse,
    MePlayerRecentlyPlayedGetResponse,
    MePlayerRepeatPutResponse,
    MePlayerSeekPutResponse,
    MePlayerShufflePutResponse,
    MePlayerVolumePutResponse,
    MePlaylistsGetResponse,
    MeShowsContainsGetResponse,
    MeShowsContainsGetResponse1,
    MeShowsDeleteRequest,
    MeShowsDeleteResponse,
    MeShowsGetResponse,
    MeShowsPutRequest,
    MeShowsPutResponse,
    MeTopArtistsGetResponse,
    MeTopTracksGetResponse,
    MeTracksContainsGetResponse,
    MeTracksContainsGetResponse1,
    MeTracksDeleteRequest,
    MeTracksDeleteResponse,
    MeTracksGetResponse,
    MeTracksPutRequest,
    MeTracksPutResponse,
    PagingArtistObject,
    PagingFeaturedPlaylistObject,
    PagingPlaylistObject,
    PagingPlaylistTrackObject,
    PagingSavedAlbumObject,
    PagingSavedAudiobookObject,
    PagingSavedEpisodeObject,
    PagingSavedShowObject,
    PagingSavedTrackObject,
    PagingSimplifiedAlbumObject,
    PagingSimplifiedChapterObject,
    PagingSimplifiedEpisodeObject,
    PagingSimplifiedTrackObject,
    PagingTrackObject,
    PlaylistObject,
    PlaylistsPlaylistIdFollowersContainsGetResponse,
    PlaylistsPlaylistIdFollowersContainsGetResponse1,
    PlaylistsPlaylistIdFollowersDeleteResponse,
    PlaylistsPlaylistIdFollowersPutRequest,
    PlaylistsPlaylistIdFollowersPutResponse,
    PlaylistsPlaylistIdGetResponse,
    PlaylistsPlaylistIdImagesGetResponse,
    PlaylistsPlaylistIdImagesGetResponse1,
    PlaylistsPlaylistIdImagesPutResponse,
    PlaylistsPlaylistIdPutRequest,
    PlaylistsPlaylistIdPutResponse,
    PlaylistsPlaylistIdTracksDeleteRequest,
    PlaylistsPlaylistIdTracksDeleteResponse,
    PlaylistsPlaylistIdTracksDeleteResponse1,
    PlaylistsPlaylistIdTracksGetResponse,
    PlaylistsPlaylistIdTracksPostRequest,
    PlaylistsPlaylistIdTracksPostResponse,
    PlaylistsPlaylistIdTracksPostResponse1,
    PlaylistsPlaylistIdTracksPutRequest,
    PlaylistsPlaylistIdTracksPutResponse,
    PlaylistsPlaylistIdTracksPutResponse1,
    PrivateUserObject,
    PublicUserObject,
    QueueObject,
    RecommendationsAvailableGenreSeedsGetResponse,
    RecommendationsAvailableGenreSeedsGetResponse1,
    RecommendationsGetResponse,
    RecommendationsObject,
    SearchGetResponse,
    SearchGetResponse1,
    ShowObject,
    ShowsGetResponse,
    ShowsGetResponse1,
    ShowsIdEpisodesGetResponse,
    ShowsIdGetResponse,
    TrackObject,
    TracksGetResponse,
    TracksGetResponse1,
    TracksIdGetResponse,
    Type11,
    Type13,
    Type15,
    Type19,
    UsersUserIdGetResponse,
    UsersUserIdPlaylistsGetResponse,
    UsersUserIdPlaylistsPostRequest,
    UsersUserIdPlaylistsPostResponse,
)

app = MCPProxy(
    contact={'name': 'sonallux', 'url': 'https://github.com/sonallux/spotify-web-api'},
    description='You can use Spotify\'s Web API to discover music and podcasts, manage your Spotify library, control audio playback, and much more. Browse our available Web API endpoints using the sidebar at left, or via the navigation bar on top of this page on smaller screens.\n\nIn order to make successful Web API requests your app will need a valid access token. One can be obtained through <a href="https://developer.spotify.com/documentation/general/guides/authorization-guide/">OAuth 2.0</a>.\n\nThe base URI for all Web API requests is `https://api.spotify.com/v1`.\n\nNeed help? See our <a href="https://developer.spotify.com/documentation/web-api/guides/">Web API guides</a> for more information, or visit the <a href="https://community.spotify.com/t5/Spotify-for-Developers/bd-p/Spotify_Developer">Spotify for Developers community forum</a> to ask questions and connect with other developers.\n',
    termsOfService='https://developer.spotify.com/terms/',
    title='Spotify Web API with fixes and improvements from sonallux',
    version='2023.2.27',
    servers=[{'url': 'https://api.spotify.com/v1'}],
)


@app.get(
    '/albums',
    description=""" Get Spotify catalog information for multiple albums identified by their Spotify IDs.
 """,
    tags=['album_management', 'user_album_interaction'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_multiple_albums(ids: str, market: Optional[str] = None):
    """
    Get Several Albums

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/albums/{id}',
    description=""" Get Spotify catalog information for a single album.
 """,
    tags=['album_management', 'user_album_interaction'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_an_album(id: str, market: Optional[str] = None):
    """
    Get Album

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/albums/{id}/tracks',
    description=""" Get Spotify catalog information about an album’s tracks.
Optional parameters can be used to limit the number of tracks returned.
 """,
    tags=['album_management', 'user_album_interaction'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_an_albums_tracks(
    id: str,
    market: Optional[str] = None,
    limit: Optional[conint(ge=1, le=50)] = 20,
    offset: Optional[int] = 0,
):
    """
    Get Album Tracks

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/artists',
    description=""" Get Spotify catalog information for several artists based on their Spotify IDs.
 """,
    tags=['artist_management', 'user_follow_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_multiple_artists(ids: str):
    """
    Get Several Artists

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/artists/{id}',
    description=""" Get Spotify catalog information for a single artist identified by their unique Spotify ID.
 """,
    tags=['artist_management', 'user_follow_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_an_artist(id: str):
    """
    Get Artist

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/artists/{id}/albums',
    description=""" Get Spotify catalog information about an artist's albums.
 """,
    tags=['album_management', 'artist_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_an_artists_albums(
    id: str,
    include_groups: Optional[str] = None,
    market: Optional[str] = None,
    limit: Optional[conint(ge=1, le=50)] = 20,
    offset: Optional[int] = 0,
):
    """
    Get Artist's Albums

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/artists/{id}/related-artists',
    description=""" Get Spotify catalog information about artists similar to a given artist. Similarity is based on analysis of the Spotify community's [listening history](http://news.spotify.com/se/2010/02/03/related-artists/).
 """,
    tags=['artist_management', 'recommendations_and_search'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_an_artists_related_artists(id: str):
    """
    Get Artist's Related Artists

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/artists/{id}/top-tracks',
    description=""" Get Spotify catalog information about an artist's top tracks by country.
 """,
    tags=['artist_management', 'user_top_artists_tracks'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_an_artists_top_tracks(id: str, market: Optional[str] = None):
    """
    Get Artist's Top Tracks

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/audio-analysis/{id}',
    description=""" Get a low-level audio analysis for a track in the Spotify catalog. The audio analysis describes the track’s structure and musical content, including rhythm, pitch, and timbre.
 """,
    tags=['music_analysis'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_audio_analysis(id: str):
    """
    Get Track's Audio Analysis

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/audio-features',
    description=""" Get audio features for multiple tracks based on their Spotify IDs.
 """,
    tags=['music_analysis'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_several_audio_features(ids: str):
    """
    Get Tracks' Audio Features

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/audio-features/{id}',
    description=""" Get audio feature information for a single track identified by its unique
Spotify ID.
 """,
    tags=['music_analysis'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_audio_features(id: str):
    """
    Get Track's Audio Features

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/audiobooks',
    description=""" Get Spotify catalog information for several audiobooks identified by their Spotify IDs.<br />
**Note: Audiobooks are only available for the US, UK, Ireland, New Zealand and Australia markets.**
 """,
    tags=['audiobook_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_multiple_audiobooks(ids: str, market: Optional[str] = None):
    """
    Get Several Audiobooks

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/audiobooks/{id}',
    description=""" Get Spotify catalog information for a single audiobook.<br />
**Note: Audiobooks are only available for the US, UK, Ireland, New Zealand and Australia markets.**
 """,
    tags=[
        'audiobook_management',
        'audiobook_user_interaction',
        'user_saved_audiobooks',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_an_audiobook(id: str, market: Optional[str] = None):
    """
    Get an Audiobook

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/audiobooks/{id}/chapters',
    description=""" Get Spotify catalog information about an audiobook's chapters.<br />
**Note: Audiobooks are only available for the US, UK, Ireland, New Zealand and Australia markets.**
 """,
    tags=['audiobook_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_audiobook_chapters(
    id: str,
    market: Optional[str] = None,
    limit: Optional[conint(ge=1, le=50)] = 20,
    offset: Optional[int] = 0,
):
    """
    Get Audiobook Chapters

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/browse/categories',
    description=""" Get a list of categories used to tag items in Spotify (on, for example, the Spotify player’s “Browse” tab).
 """,
    tags=['category_management', 'recommendations_and_search'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_categories(
    country: Optional[str] = None,
    locale: Optional[str] = None,
    limit: Optional[conint(ge=1, le=50)] = 20,
    offset: Optional[int] = 0,
):
    """
    Get Several Browse Categories

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/browse/categories/{category_id}',
    description=""" Get a single category used to tag items in Spotify (on, for example, the Spotify player’s “Browse” tab).
 """,
    tags=['category_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_a_category(
    category_id: str, country: Optional[str] = None, locale: Optional[str] = None
):
    """
    Get Single Browse Category

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/browse/categories/{category_id}/playlists',
    description=""" Get a list of Spotify playlists tagged with a particular category.
 """,
    tags=['category_management', 'playlist_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_a_categories_playlists(
    category_id: str,
    country: Optional[str] = None,
    limit: Optional[conint(ge=1, le=50)] = 20,
    offset: Optional[int] = 0,
):
    """
    Get Category's Playlists

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/browse/featured-playlists',
    description=""" Get a list of Spotify featured playlists (shown, for example, on a Spotify player's 'Browse' tab).
 """,
    tags=[
        'category_management',
        'playlist_management',
        'user_playlists',
        'recommendations_and_search',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_featured_playlists(
    country: Optional[str] = None,
    locale: Optional[str] = None,
    timestamp: Optional[str] = None,
    limit: Optional[conint(ge=1, le=50)] = 20,
    offset: Optional[int] = 0,
):
    """
    Get Featured Playlists

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/browse/new-releases',
    description=""" Get a list of new album releases featured in Spotify (shown, for example, on a Spotify player’s “Browse” tab).
 """,
    tags=['recommendations_and_search'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_new_releases(
    country: Optional[str] = None,
    limit: Optional[conint(ge=1, le=50)] = 20,
    offset: Optional[int] = 0,
):
    """
    Get New Releases

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/chapters',
    description=""" Get Spotify catalog information for several chapters identified by their Spotify IDs.<br />
**Note: Chapters are only available for the US, UK, Ireland, New Zealand and Australia markets.**
 """,
    tags=['audiobook_management', 'audiobook_user_interaction'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_several_chapters(ids: str, market: Optional[str] = None):
    """
    Get Several Chapters

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/chapters/{id}',
    description=""" Get Spotify catalog information for a single chapter.<br />
**Note: Chapters are only available for the US, UK, Ireland, New Zealand and Australia markets.**
 """,
    tags=['audiobook_management', 'audiobook_user_interaction'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_a_chapter(id: str, market: Optional[str] = None):
    """
    Get a Chapter

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/episodes',
    description=""" Get Spotify catalog information for several episodes based on their Spotify IDs.
 """,
    tags=['episode_management', 'show_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_multiple_episodes(ids: str, market: Optional[str] = None):
    """
    Get Several Episodes

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/episodes/{id}',
    description=""" Get Spotify catalog information for a single episode identified by its
unique Spotify ID.
 """,
    tags=['episode_management', 'show_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_an_episode(id: str, market: Optional[str] = None):
    """
    Get Episode

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/markets',
    description=""" Get the list of markets where Spotify is available.
 """,
    tags=['category_management', 'recommendations_and_search'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_available_markets():
    """
    Get Available Markets

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/me',
    description=""" Get detailed profile information about the current user (including the
current user's username).
 """,
    tags=['user_profile_management', 'user_profile_handling'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_current_users_profile():
    """
    Get Current User's Profile

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/me/albums',
    description=""" Remove one or more albums from the current user's 'Your Music' library.
 """,
    tags=['user_album_interaction', 'user_saved_content'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def remove_albums_user(ids: str, body: MeAlbumsDeleteRequest = None):
    """
    Remove Users' Saved Albums

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/me/albums',
    description=""" Get a list of the albums saved in the current Spotify user's 'Your Music' library.
 """,
    tags=['user_album_interaction', 'user_saved_content'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_users_saved_albums(
    limit: Optional[conint(ge=1, le=50)] = 20,
    offset: Optional[int] = 0,
    market: Optional[str] = None,
):
    """
    Get User's Saved Albums

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/me/albums',
    description=""" Save one or more albums to the current user's 'Your Music' library.
 """,
    tags=['album_management', 'user_album_interaction'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def save_albums_user(ids: str, body: MeAlbumsPutRequest = None):
    """
    Save Albums for Current User

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/me/albums/contains',
    description=""" Check if one or more albums is already saved in the current Spotify user's 'Your Music' library.
 """,
    tags=['user_album_interaction', 'user_saved_content'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def check_users_saved_albums(ids: str):
    """
    Check User's Saved Albums

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/me/audiobooks',
    description=""" Remove one or more audiobooks from the Spotify user's library.
 """,
    tags=[
        'audiobook_management',
        'audiobook_user_interaction',
        'user_saved_audiobooks',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def remove_audiobooks_user(ids: str):
    """
    Remove User's Saved Audiobooks

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/me/audiobooks',
    description=""" Get a list of the audiobooks saved in the current Spotify user's 'Your Music' library.
 """,
    tags=[
        'audiobook_management',
        'audiobook_user_interaction',
        'user_saved_audiobooks',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_users_saved_audiobooks(
    limit: Optional[conint(ge=1, le=50)] = 20, offset: Optional[int] = 0
):
    """
    Get User's Saved Audiobooks

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/me/audiobooks',
    description=""" Save one or more audiobooks to the current Spotify user's library.
 """,
    tags=[
        'audiobook_management',
        'audiobook_user_interaction',
        'user_saved_audiobooks',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def save_audiobooks_user(ids: str):
    """
    Save Audiobooks for Current User

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/me/audiobooks/contains',
    description=""" Check if one or more audiobooks are already saved in the current Spotify user's library.
 """,
    tags=[
        'audiobook_management',
        'audiobook_user_interaction',
        'user_saved_audiobooks',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def check_users_saved_audiobooks(ids: str):
    """
    Check User's Saved Audiobooks

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/me/episodes',
    description=""" Remove one or more episodes from the current user's library.
 """,
    tags=['user_saved_episodes', 'user_saved_content', 'episode_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def remove_episodes_user(ids: str, body: MeEpisodesDeleteRequest = None):
    """
    Remove User's Saved Episodes

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/me/episodes',
    description=""" Get a list of the episodes saved in the current Spotify user's library.
 """,
    tags=['user_saved_episodes', 'episode_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_users_saved_episodes(
    market: Optional[str] = None,
    limit: Optional[conint(ge=1, le=50)] = 20,
    offset: Optional[int] = 0,
):
    """
    Get User's Saved Episodes

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/me/episodes',
    description=""" Save one or more episodes to the current user's library.
 """,
    tags=['user_saved_episodes', 'episode_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def save_episodes_user(ids: str, body: MeEpisodesPutRequest = None):
    """
    Save Episodes for Current User

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/me/episodes/contains',
    description=""" Check if one or more episodes is already saved in the current Spotify user's 'Your Episodes' library.
 """,
    tags=['user_saved_episodes', 'episode_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def check_users_saved_episodes(ids: str):
    """
    Check User's Saved Episodes

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/me/following',
    description=""" Remove the current user as a follower of one or more artists or other Spotify users.
 """,
    tags=['user_follow_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def unfollow_artists_users(
    type: Type11, ids: str = ..., body: MeFollowingDeleteRequest = None
):
    """
    Unfollow Artists or Users

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/me/following',
    description=""" Get the current user's followed artists.
 """,
    tags=['user_follow_management', 'artist_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_followed(
    type: Type13, after: Optional[str] = None, limit: Optional[conint(ge=1, le=50)] = 20
):
    """
    Get Followed Artists

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/me/following',
    description=""" Add the current user as a follower of one or more artists or other Spotify users.
 """,
    tags=['user_follow_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def follow_artists_users(
    type: Type15, ids: str = ..., body: MeFollowingPutRequest = None
):
    """
    Follow Artists or Users

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/me/following/contains',
    description=""" Check to see if the current user is following one or more artists or other Spotify users.
 """,
    tags=['user_follow_management', 'user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def check_current_user_follows(type: Type15, ids: str = ...):
    """
    Check If User Follows Artists or Users

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/me/player',
    description=""" Get information about the user’s current playback state, including track or episode, progress, and active device.
 """,
    tags=['user_playback_statistics', 'user_playback_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_information_about_the_users_current_playback(
    market: Optional[str] = None, additional_types: Optional[str] = None
):
    """
    Get Playback State

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/me/player',
    description=""" Transfer playback to a new device and determine if it should start playing.
 """,
    tags=['user_playback_management', 'user_device_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def transfer_a_users_playback(body: MePlayerPutRequest = None):
    """
    Transfer Playback

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/me/player/currently-playing',
    description=""" Get the object currently being played on the user's Spotify account.
 """,
    tags=['user_playback_statistics', 'user_playback_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_the_users_currently_playing_track(
    market: Optional[str] = None, additional_types: Optional[str] = None
):
    """
    Get Currently Playing Track

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/me/player/devices',
    description=""" Get information about a user’s available devices.
 """,
    tags=['user_device_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_a_users_available_devices():
    """
    Get Available Devices

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/me/player/next',
    description=""" Skips to next track in the user’s queue.
 """,
    tags=['user_device_management', 'user_playback_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def skip_users_playback_to_next_track(device_id: Optional[str] = None):
    """
    Skip To Next

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/me/player/pause',
    description=""" Pause playback on the user's account.
 """,
    tags=['user_playback_management', 'user_device_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def pause_a_users_playback(device_id: Optional[str] = None):
    """
    Pause Playback

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/me/player/play',
    description=""" Start a new context or resume current playback on the user's active device.
 """,
    tags=[
        'user_playback_management',
        'user_device_management',
        'user_playback_statistics',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def start_a_users_playback(
    device_id: Optional[str] = None, body: MePlayerPlayPutRequest = None
):
    """
    Start/Resume Playback

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/me/player/previous',
    description=""" Skips to previous track in the user’s queue.
 """,
    tags=['user_playback_management', 'user_device_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def skip_users_playback_to_previous_track(device_id: Optional[str] = None):
    """
    Skip To Previous

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/me/player/queue',
    description=""" Get the list of objects that make up the user's queue.
 """,
    tags=['user_playback_management', 'user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_queue():
    """
    Get the User's Queue

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/me/player/queue',
    description=""" Add an item to the end of the user's current playback queue.
 """,
    tags=['user_playback_management', 'user_device_management', 'playlist_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def add_to_queue(uri: str, device_id: Optional[str] = None):
    """
    Add Item to Playback Queue

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/me/player/recently-played',
    description=""" Get tracks from the current user's recently played tracks.
_**Note**: Currently doesn't support podcast episodes._
 """,
    tags=['user_playback_statistics', 'user_playback_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_recently_played(
    limit: Optional[conint(ge=1, le=50)] = 20,
    after: Optional[int] = None,
    before: Optional[int] = None,
):
    """
    Get Recently Played Tracks

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/me/player/repeat',
    description=""" Set the repeat mode for the user's playback. Options are repeat-track,
repeat-context, and off.
 """,
    tags=['user_playback_settings', 'user_playback_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def set_repeat_mode_on_users_playback(state: str, device_id: Optional[str] = None):
    """
    Set Repeat Mode

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/me/player/seek',
    description=""" Seeks to the given position in the user’s currently playing track.
 """,
    tags=['user_playback_management', 'user_device_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def seek_to_position_in_currently_playing_track(
    position_ms: int, device_id: Optional[str] = None
):
    """
    Seek To Position

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/me/player/shuffle',
    description=""" Toggle shuffle on or off for user’s playback.
 """,
    tags=['user_playback_management', 'user_playback_settings'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def toggle_shuffle_for_users_playback(state: bool, device_id: Optional[str] = None):
    """
    Toggle Playback Shuffle

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/me/player/volume',
    description=""" Set the volume for the user’s current playback device.
 """,
    tags=[
        'user_playback_management',
        'user_playback_settings',
        'user_device_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def set_volume_for_users_playback(volume_percent: int, device_id: Optional[str] = None):
    """
    Set Playback Volume

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/me/playlists',
    description=""" Get a list of the playlists owned or followed by the current Spotify
user.
 """,
    tags=['user_playlists', 'user_profile_management', 'user_profile_handling'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_a_list_of_current_users_playlists(
    limit: Optional[conint(ge=1, le=50)] = 20, offset: Optional[int] = 0
):
    """
    Get Current User's Playlists

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/me/shows',
    description=""" Delete one or more shows from current Spotify user's library.
 """,
    tags=['user_saved_shows', 'user_saved_content'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def remove_shows_user(
    ids: str, market: Optional[str] = None, body: MeShowsDeleteRequest = None
):
    """
    Remove User's Saved Shows

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/me/shows',
    description=""" Get a list of shows saved in the current Spotify user's library. Optional parameters can be used to limit the number of shows returned.
 """,
    tags=['user_saved_shows', 'user_saved_content'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_users_saved_shows(
    limit: Optional[conint(ge=1, le=50)] = 20, offset: Optional[int] = 0
):
    """
    Get User's Saved Shows

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/me/shows',
    description=""" Save one or more shows to current Spotify user's library.
 """,
    tags=['user_saved_shows', 'user_saved_content'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def save_shows_user(ids: str, body: MeShowsPutRequest = None):
    """
    Save Shows for Current User

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/me/shows/contains',
    description=""" Check if one or more shows is already saved in the current Spotify user's library.
 """,
    tags=['user_saved_shows', 'user_saved_content', 'user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def check_users_saved_shows(ids: str):
    """
    Check User's Saved Shows

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/me/top/artists',
    description=""" Get the current user's top artists based on calculated affinity.
 """,
    tags=['artist_management', 'user_top_artists_tracks'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_users_top_artists(
    time_range: Optional[str] = 'medium_term',
    limit: Optional[conint(ge=1, le=50)] = 20,
    offset: Optional[int] = 0,
):
    """
    Get User's Top Artists

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/me/top/tracks',
    description=""" Get the current user's top tracks based on calculated affinity.
 """,
    tags=['user_top_artists_tracks', 'user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_users_top_tracks(
    time_range: Optional[str] = 'medium_term',
    limit: Optional[conint(ge=1, le=50)] = 20,
    offset: Optional[int] = 0,
):
    """
    Get User's Top Tracks

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/me/tracks',
    description=""" Remove one or more tracks from the current user's 'Your Music' library.
 """,
    tags=['user_saved_content', 'user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def remove_tracks_user(ids: str, body: MeTracksDeleteRequest = None):
    """
    Remove User's Saved Tracks

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/me/tracks',
    description=""" Get a list of the songs saved in the current Spotify user's 'Your Music' library.
 """,
    tags=['user_saved_content', 'user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_users_saved_tracks(
    market: Optional[str] = None,
    limit: Optional[conint(ge=1, le=50)] = 20,
    offset: Optional[int] = 0,
):
    """
    Get User's Saved Tracks

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/me/tracks',
    description=""" Save one or more tracks to the current user's 'Your Music' library.
 """,
    tags=['user_saved_content', 'user_profile_management', 'user_profile_handling'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def save_tracks_user(ids: str, body: MeTracksPutRequest = None):
    """
    Save Tracks for Current User

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/me/tracks/contains',
    description=""" Check if one or more tracks is already saved in the current Spotify user's 'Your Music' library.
 """,
    tags=['user_saved_content', 'user_profile_management', 'user_profile_handling'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def check_users_saved_tracks(ids: str):
    """
    Check User's Saved Tracks

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/playlists/{playlist_id}',
    description=""" Get a playlist owned by a Spotify user.
 """,
    tags=['playlist_management', 'user_playlists'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_playlist(
    playlist_id: str,
    market: Optional[str] = None,
    fields: Optional[str] = None,
    additional_types: Optional[str] = None,
):
    """
    Get Playlist

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/playlists/{playlist_id}',
    description=""" Change a playlist's name and public/private state. (The user must, of
course, own the playlist.)
 """,
    tags=['playlist_management', 'user_playlists', 'playlist_tracks_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def change_playlist_details(
    playlist_id: str, body: PlaylistsPlaylistIdPutRequest = None
):
    """
    Change Playlist Details

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/playlists/{playlist_id}/followers',
    description=""" Remove the current user as a follower of a playlist.
 """,
    tags=['playlist_management', 'user_playlists'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def unfollow_playlist(playlist_id: str):
    """
    Unfollow Playlist

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/playlists/{playlist_id}/followers',
    description=""" Add the current user as a follower of a playlist.
 """,
    tags=['playlist_management', 'user_profile_management', 'user_playlists'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def follow_playlist(
    playlist_id: str, body: PlaylistsPlaylistIdFollowersPutRequest = None
):
    """
    Follow Playlist

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/playlists/{playlist_id}/followers/contains',
    description=""" Check to see if one or more Spotify users are following a specified playlist.
 """,
    tags=['playlist_management', 'user_follow_management', 'user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def check_if_user_follows_playlist(playlist_id: str, ids: str = ...):
    """
    Check if Users Follow Playlist

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/playlists/{playlist_id}/images',
    description=""" Get the current image associated with a specific playlist.
 """,
    tags=['playlist_management', 'playlist_cover_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_playlist_cover(playlist_id: str):
    """
    Get Playlist Cover Image

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/playlists/{playlist_id}/images',
    description=""" Replace the image used to represent a specific playlist.
 """,
    tags=['playlist_management', 'playlist_cover_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def upload_custom_playlist_cover(playlist_id: str):
    """
    Add Custom Playlist Cover Image

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/playlists/{playlist_id}/tracks',
    description=""" Remove one or more items from a user's playlist.
 """,
    tags=['playlist_management', 'playlist_tracks_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def remove_tracks_playlist(
    playlist_id: str, body: PlaylistsPlaylistIdTracksDeleteRequest = None
):
    """
    Remove Playlist Items

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/playlists/{playlist_id}/tracks',
    description=""" Get full details of the items of a playlist owned by a Spotify user.
 """,
    tags=['playlist_management', 'user_playlists'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_playlists_tracks(
    playlist_id: str,
    market: Optional[str] = None,
    fields: Optional[str] = None,
    limit: Optional[conint(ge=1, le=100)] = 20,
    offset: Optional[int] = 0,
    additional_types: Optional[str] = None,
):
    """
    Get Playlist Items

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/playlists/{playlist_id}/tracks',
    description=""" Add one or more items to a user's playlist.
 """,
    tags=['playlist_management', 'playlist_tracks_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def add_tracks_to_playlist(
    playlist_id: str,
    position: Optional[int] = None,
    uris: Optional[str] = None,
    body: PlaylistsPlaylistIdTracksPostRequest = None,
):
    """
    Add Items to Playlist

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/playlists/{playlist_id}/tracks',
    description=""" Either reorder or replace items in a playlist depending on the request's parameters.
To reorder items, include `range_start`, `insert_before`, `range_length` and `snapshot_id` in the request's body.
To replace items, include `uris` as either a query parameter or in the request's body.
Replacing items in a playlist will overwrite its existing items. This operation can be used for replacing or clearing items in a playlist.
<br/>
**Note**: Replace and reorder are mutually exclusive operations which share the same endpoint, but have different parameters.
These operations can't be applied together in a single request.
 """,
    tags=['playlist_management', 'playlist_tracks_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def reorder_or_replace_playlists_tracks(
    playlist_id: str,
    uris: Optional[str] = None,
    body: PlaylistsPlaylistIdTracksPutRequest = None,
):
    """
    Update Playlist Items

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/recommendations',
    description=""" Recommendations are generated based on the available information for a given seed entity and matched against similar artists and tracks. If there is sufficient information about the provided seeds, a list of tracks will be returned together with pool size details.

For artists and tracks that are very new or obscure there might not be enough data to generate a list of tracks.
 """,
    tags=['recommendations_and_search'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_recommendations(
    limit: Optional[conint(ge=1, le=100)] = 20,
    market: Optional[str] = None,
    seed_artists: Optional[str] = None,
    seed_genres: Optional[str] = None,
    seed_tracks: Optional[str] = None,
    min_acousticness: Optional[confloat(ge=0.0, le=1.0)] = None,
    max_acousticness: Optional[confloat(ge=0.0, le=1.0)] = None,
    target_acousticness: Optional[confloat(ge=0.0, le=1.0)] = None,
    min_danceability: Optional[confloat(ge=0.0, le=1.0)] = None,
    max_danceability: Optional[confloat(ge=0.0, le=1.0)] = None,
    target_danceability: Optional[confloat(ge=0.0, le=1.0)] = None,
    min_duration_ms: Optional[int] = None,
    max_duration_ms: Optional[int] = None,
    target_duration_ms: Optional[int] = None,
    min_energy: Optional[confloat(ge=0.0, le=1.0)] = None,
    max_energy: Optional[confloat(ge=0.0, le=1.0)] = None,
    target_energy: Optional[confloat(ge=0.0, le=1.0)] = None,
    min_instrumentalness: Optional[confloat(ge=0.0, le=1.0)] = None,
    max_instrumentalness: Optional[confloat(ge=0.0, le=1.0)] = None,
    target_instrumentalness: Optional[confloat(ge=0.0, le=1.0)] = None,
    min_key: Optional[conint(ge=0, le=11)] = None,
    max_key: Optional[conint(ge=0, le=11)] = None,
    target_key: Optional[conint(ge=0, le=11)] = None,
    min_liveness: Optional[confloat(ge=0.0, le=1.0)] = None,
    max_liveness: Optional[confloat(ge=0.0, le=1.0)] = None,
    target_liveness: Optional[confloat(ge=0.0, le=1.0)] = None,
    min_loudness: Optional[float] = None,
    max_loudness: Optional[float] = None,
    target_loudness: Optional[float] = None,
    min_mode: Optional[conint(ge=0, le=1)] = None,
    max_mode: Optional[conint(ge=0, le=1)] = None,
    target_mode: Optional[conint(ge=0, le=1)] = None,
    min_popularity: Optional[conint(ge=0, le=100)] = None,
    max_popularity: Optional[conint(ge=0, le=100)] = None,
    target_popularity: Optional[conint(ge=0, le=100)] = None,
    min_speechiness: Optional[confloat(ge=0.0, le=1.0)] = None,
    max_speechiness: Optional[confloat(ge=0.0, le=1.0)] = None,
    target_speechiness: Optional[confloat(ge=0.0, le=1.0)] = None,
    min_tempo: Optional[float] = None,
    max_tempo: Optional[float] = None,
    target_tempo: Optional[float] = None,
    min_time_signature: Optional[conint(le=11)] = None,
    max_time_signature: Optional[int] = None,
    target_time_signature: Optional[int] = None,
    min_valence: Optional[confloat(ge=0.0, le=1.0)] = None,
    max_valence: Optional[confloat(ge=0.0, le=1.0)] = None,
    target_valence: Optional[confloat(ge=0.0, le=1.0)] = None,
):
    """
    Get Recommendations

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/recommendations/available-genre-seeds',
    description=""" Retrieve a list of available genres seed parameter values for [recommendations](/documentation/web-api/reference/#/operations/get-recommendations).
 """,
    tags=['category_management', 'recommendations_and_search'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_recommendation_genres():
    """
    Get Available Genre Seeds

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/search',
    description=""" Get Spotify catalog information about albums, artists, playlists, tracks, shows, episodes or audiobooks
that match a keyword string.<br />
**Note: Audiobooks are only available for the US, UK, Ireland, New Zealand and Australia markets.**
 """,
    tags=['recommendations_and_search'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def search(
    q: str,
    type: Type19 = ...,
    market: Optional[str] = None,
    limit: Optional[conint(ge=1, le=50)] = 20,
    offset: Optional[conint(ge=0, le=1000)] = 0,
    include_external: Optional[IncludeExternal] = None,
):
    """
    Search for Item

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/shows',
    description=""" Get Spotify catalog information for several shows based on their Spotify IDs.
 """,
    tags=['show_management', 'user_saved_shows'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_multiple_shows(market: Optional[str] = None, ids: str = ...):
    """
    Get Several Shows

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/shows/{id}',
    description=""" Get Spotify catalog information for a single show identified by its
unique Spotify ID.
 """,
    tags=['show_management', 'user_saved_shows', 'user_saved_content'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_a_show(market: Optional[str] = None, id: str = ...):
    """
    Get Show

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/shows/{id}/episodes',
    description=""" Get Spotify catalog information about an show’s episodes. Optional parameters can be used to limit the number of episodes returned.
 """,
    tags=['episode_management', 'show_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_a_shows_episodes(
    id: str,
    market: Optional[str] = None,
    limit: Optional[conint(ge=1, le=50)] = 20,
    offset: Optional[int] = 0,
):
    """
    Get Show Episodes

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/tracks',
    description=""" Get Spotify catalog information for multiple tracks based on their Spotify IDs.
 """,
    tags=['artist_management', 'music_analysis', 'recommendations_and_search'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_several_tracks(market: Optional[str] = None, ids: str = ...):
    """
    Get Several Tracks

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/tracks/{id}',
    description=""" Get Spotify catalog information for a single track identified by its
unique Spotify ID.
 """,
    tags=['music_analysis', 'recommendations_and_search'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_track(id: str, market: Optional[str] = None):
    """
    Get Track

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/users/{user_id}',
    description=""" Get public profile information about a Spotify user.
 """,
    tags=['user_profile_management', 'user_profile_handling'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_users_profile(user_id: str):
    """
    Get User's Profile

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/users/{user_id}/playlists',
    description=""" Get a list of the playlists owned or followed by a Spotify user.
 """,
    tags=['user_playlists', 'user_profile_management', 'user_profile_handling'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_list_users_playlists(
    user_id: str, limit: Optional[conint(ge=1, le=50)] = 20, offset: Optional[int] = 0
):
    """
    Get User's Playlists

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/users/{user_id}/playlists',
    description=""" Create a playlist for a Spotify user. (The playlist will be empty until
you [add tracks](/documentation/web-api/reference/#/operations/add-tracks-to-playlist).)
 """,
    tags=['playlist_management', 'user_playlists', 'user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_playlist(user_id: str, body: UsersUserIdPlaylistsPostRequest = None):
    """
    Create Playlist

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
